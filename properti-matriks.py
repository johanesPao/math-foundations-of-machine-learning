import numpy as np
import torch
import tensorflow as tf

X = np.array([[1, 2], [3, 4]])
X_pt = torch.tensor([[1, 2], [3, 4.]])  # torch.norm() requires float type
X_tf = tf.Variable([[1, 2], [3, 4.]])  # tf.norm() also requires float type

# FROBENIUS FORM
print('----FROBENIUS FORM')
print('\nX:')
print(X)
print('\n(1**2 + 2**2 + 3**2 + 4**2)**(1/2):')
print((1**2 + 2**2 + 3**2 + 4**2)**(1/2))
print('\nnp.linalg.norm(X):')
print(np.linalg.norm(X))
print('\nX_pt:')
print(X_pt)
print('\ntorch.norm(X_pt):')
print(torch.norm(X_pt))
print('\nX_tf:')
print(X_tf)
print('\ntf.norm(X_tf):')
print(tf.norm(X_tf))

# MATRIX MULTIPLICATION
A = np.array([[3, 4], [5, 6], [7, 8]])
b = np.array([1, 2])
A_pt = torch.tensor([[3, 4], [5, 6], [7, 8]])
b_pt = torch.tensor([1, 2])
A_tf = tf.Variable([[3, 4], [5, 6], [7, 8]])
b_tf = tf.Variable([1, 2])

print('\n---MATRIX MULTIPLICATION')
print('\nA:')
print(A)
print('\nb:')
print(b)
print('\nnp.dot(A, b):')
print(np.dot(A, b))
print('\nA_pt:')
print(A_pt)
print('\nb_pt:')
print(b_pt)
print('\ntorch.matmul(A, b_pt):')
print(torch.matmul(A_pt, b_pt))
print('\nA_tf:')
print(A_tf)
print('\nb_tf:')
print(b_tf)
print('\ntf.linalg.matvec(A, b_tf):')
print(tf.linalg.matvec(A_tf, b_tf))

B = np.array([[1, 9], [2, 0]])
# there is a bug that NumPy will cast int32, however torch need it in int64
B_pt = torch.from_numpy(B.astype(np.int64))
B_tf = tf.convert_to_tensor(B, dtype=tf.int32)

print('\nB:')
print(B)
print('\nnp.dot(A, B):')
print(np.dot(A, B))
print('\nB_pt')
print(B_pt)
print('\ntorch.matmul(A_pt, B_pt):')
print(torch.matmul(A_pt, B_pt))
print('\nB_tf:')
print(B_tf)
print('\ntf.matmul(A_tf, B_tf):')
print(tf.matmul(A_tf, B_tf))

# SYMMETRIC MATRICES AND IDENTITY MATRICES
X_sym = np.array([[0, 1, 2], [1, 7, 8], [2, 8, 9]])
print('\n---SYMMETRIC MATRICES AND IDENTITY MATRICES')
print('\nX_sym:')
print(X_sym)
print('\nX_sym.T:')
print(X_sym.T)
print('\nX_sym.T == X_sym:')
print(X_sym.T == X_sym)

I = torch.tensor([[1, 0, 0], [0, 1, 0], [0, 0, 1]])
x_pt = torch.tensor([25, 2, 5])
print('\nI:')
print(I)
print('\nx_pt:')
print(x_pt)
print('\ntorch.matmul(I, x_pt):')
print(torch.matmul(I, x_pt))

# MATRIX INVERSION
print('\n---MATRIX INVERSION')
X = np.array([[4, 2], [-5, -3]])
print('\nX:')
print(X)
print('\nXinv = np.linalg.inv(X):')
Xinv = np.linalg.inv(X)
print(Xinv)
y = np.array([4, -7])
print('\ny:')
print(y)
print('\nw = np.dot(Xinv, y):')
w = np.dot(Xinv, y)
print(w)
print('\nShow that y = Xw:')
print('np.dot(X, w):')
print(np.dot(X, w))
print('\nX = np.array([[-4, 1], [-8, 2]]):')
X = np.array([[-4, 1], [-8, 2]])
print(X)
# print('\nXinv = np.linalg.inv(X):')
# Xinv = np.linalg.inv(X)

# MATRIK ORTHOGONAL
K = torch.tensor([[2/3, 1/3, 2/3], [-2/3, 2/3, 1/3], [1/3, 2/3, -2/3]])
Kcol_1 = K[:, 0]
Kcol_2 = K[:, 1]
Kcol_3 = K[:, 2]
print('\n---MATRIKS ORTHOGONAL')
print('\nK:')
print(K)
print('\nKcol_1:')
print(Kcol_1)
print('\nKcol_2:')
print(Kcol_2)
print('\nKcol_3:')
print(Kcol_3)
print('\ntorch.dot(Kcol_1, Kcol_2):')
print(torch.dot(Kcol_1, Kcol_2))
print('\ntorch.dot(Kcol_1, Kcol_3):')
print(torch.dot(Kcol_1, Kcol_3))
print('\ntorch.dot(Kcol_2, Kcol_3):')
print(torch.dot(Kcol_2, Kcol_3))
print('\ntorch.norm(Kcol_1):')
print(torch.norm(Kcol_1))
print('\ntorch.norm(Kcol_2):')
print(torch.norm(Kcol_2))
print('\ntorch.norm(Kcol_3):')
print(torch.norm(Kcol_3))
print('\ntorch.matmul(K.T, K):')
print(torch.matmul(K.T, K))
